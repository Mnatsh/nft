Инструкция по созданию и ведению коллекции Nft

1. Создаем новый проект Nft.
  1.1 Придумываем название (NameCol, создаем каталог с таким названием, копируем в этот каталог файлы из папки d:\nft\template\

2. В каталоге \dev\ есть база данных template для access. Переименовываем ее NameCol. Заходим и настраиваем под новый проект.
  2.1 Редактируем в таблице init поля - форма EditInit
	* "nameCollection" - путь к файлам изображения коллекции
	* "pathCollection" - путь к коллекции
	* "next_item_index" - 
	* "countTrait" - кол-во"trait_type"
	* "trait" - имена "trait_type"
	* "owner_address" - адрес владельца коллекции
	* "owner_addressTest" - адрес владельца коллекции тестовой сети
	* "addressCollection" - адрес коллекции
	* "addressCollectionTest" - адрес коллекции тестовой сети

	* "royality_perc" - 
	* "royality_base" - 
	* "royality_address" - адрес получателя рояльти

	* "collection_content" - collection_content
	* "common_content" - common_content 

	* "CIDmeta" - CID meta-файлов
	* "CIDCollection" - CID meta-файла коллекции
	* "CIDimg" - CID файлов изображений

	  заготовки файлов Json - 8 штук
	* "templateJSONMetaItem"
	* "templateJSONMetaItemTrait"
	* "templateJSONDeployCollection"
	* "templateJSONNewParamCollection"
	* "templateJSONMintItem"
	* "templateJSONMintBatchItem"
	* "templateItemInBatch"

  
  2.2 Создаем таблицу base, содержащую поля Nft. Она содержит поля, необходимые для формирования Nft:
	* "nameNft"
	* "description"
	* "trait1"
	* "trait2"
	...
	* "trait10". Всего до 10 "trait". Одна запись - одно Nft.
	Кроме того, каждая запись содержит следующие поля:
	* "image" - имя файла изображения Nft
	* "counter" - порядковый номер(item) Nft
	* "owner" - адрес первого владельца Nft
	* "status" - статус данной Nft: "подготовка", "готовность",  "заминчена", "стабильно" 
	* "countMint" - номер операции минтинга
	
  Данные поля заполняются по мере готовности необходимых данных.
  Для минта обязательны к заполнению следующие поля:
  - nameNft, description, trait1, trait2, trait3, trait4, trait5... Всего до 10 "trait"
  - имя файла изображения Nft. Все файлы исходных изображений помещаются в каталог \img\
    Когда появляются одно или несколько готовых для минта описаний, для них устанавливаются флаги "готова для минта". Это можно сделать автоматически для групповых минтов.
  
  2.3 В таблице Minting содержится информацию о всех актах минтинга. Одна запись - один минт, одиночный или групповой.
      Состав полей:
	* "numOp" -  номер операции минтинга
	* "dateMint" -  Дата минтинга
	* "startIndex" -  стартовый номер Nft
	* "countItem" -  кол-во Nft для минтинга
	* "status" -  статус операции: "подготовка", "готовность",  "заминчена", "стабильно" 
	* "CID" -  CID файлов изображений в ipfs

3. Вначале деплоим смарт-контракт коллекции. Для этого в таблице init заполняем поля
	* "royality_perc" - 
	* "royality_base" - 
	* "royality_address" - адрес получателя рояльти

Для этого заходим в  форму Minting. Пока не задеплоин смарт-контракт коллекции, здесь доступна только команда "Приготовить файл для deploy коллекции". Нажимаем, получаем файл "project/NameCol/actions/newCollection.json".
Процесс подготовки к развертыванию смарт-контракта коллекции идет одновременно с подготовкой первой порции nft.

---------- действия из среды BluiPrint - создание, разворачивание и управление контрактами ----------
Деплоим коллекцию по информации из файла "project/NameCol/actions/newCollection.json"
По результатам получаем развернутую коллекцию.
В таблице init поля (форма EditInit) редактируем поля (в зависимости от основной или тестовой сети):
	* "owner_address" = адрес владельца коллекции   ИЛИ 	* "owner_addressTest" = адрес владельца коллекции тестовой сети
	* "addressCollection" = адрес коллекции         ИЛИ     * "addressCollectionTest" = адрес коллекции тестовой сети

	* "collection_content" - collection_content
	* "common_content" - common_content 


----------   ----------

  3.0 Определяем необходимые параметры в таблице init
  
  3.1 Когда появляется одно или больше NFT, готовых для минтинга, в форме Minting запускаем процедуру "Создать новый минт". 
  Создается новая запись с таблице Minting и заполняются поля 
      * "numOp" - "номер операции минтинга"     - авто: очередной порядковый номер
	  * "dateMint" - "Дата минтинга"               - авто: текущая дата
	  * "startIndex" - "стартовый номер Nft"         - авто: на 1 больше, чем "номер"  + "кол-во Nft" в предыдущей записи
	  * "countItem" - "кол-во Nft для минтинга"     - авто: число Nft, готовых в таблице base
  3.2 В таблице base просматриваем поля Nft, готовых к минту:
	  -  по полям 	
			* "trait1"
			* "trait2"
			...
			* "trait10".
		формируем "templateJSONMetaItemTrait"

      - по полям:
		  * item, индекс Nft в коллекции 
		  * номер операции минтинга
		  * "image" - имя файла изображения Nft	  
		  * "templateJSONMetaItemTrait"
	формируем "templateJSONMetaItem". Сохраняем его в "\meta\" под именами "<item>.json"
	
  3.3 Файлы изображений выбранных Nft копируются в папку "\img\mint<номер>\" под именами "<item>.<scrext>"

4. Папка с изображениями ("\img\mint<номер>\") загружается во внешнее хранилище (ipfs). Получаем "CID файлов изображений в ipfs".
   Папка с метафайлами ("\meta\") загружается во внешнее хранилище (ipfs). Получаем "CID файлов meta в ipfs"

5. Помещаем полученные CID в таблицу init.

8. В таблице init изменяем поля 
  * collection_content
  * common_content 
  * CIDmeta
  * CIDimg

9. Запускаем процедуру подготовки файлов JSON, управляющих минтом. 
  - Создаются файлы newNftMint.json или newNftBatchMint.json
  - Создается файл newCollection.json для изменения параметров коллекции

---------- Делаем сначала в тестовой сети -------------
10. Средствами ts-nft производим минт (одиночный или групповой) подготовленных nft, а затем средствами ts-nft производим изменение параметров коллекции, если есть необходимость. Например, если меняется способ доступа к файлам в ipfs и нужно изменить common_content в смарт-контракте коллекции. Или просто изменить параметры коллекции.
---------- После получения удовлетворительных результатов переходим в основную сеть -------------

11. В таблице Minting меняем статус "операции" на "задеплоино", в таблице base меняем статус "операции" на "заминчена",

12. Через 1-2 недели, если нет претензий к работе коллекции, меняем статус операции на "стабильно" 


----------------- Форматы выходных json файлов ---------------------------------------------

1. Метафайл в формате json всей коллекции Collection.json
{  "name": "<0>",  "description": "<1>",  "image": "<2>",  "cover_image": "<3>",  "social_links": [    <4>  ]}
набор ссылок на соцсети
"<0>"
--------------------------------------------------------------
2. Метафайл в формате json каждой nft <item>.json

{  "name": "<0>",  "description": "<1>",  "image": "<2>",  "content_url": "<3>",  "attributes": [    <4>  ]}

набор trait-ов для помещения внутрь пакетного минта Nft
3
    {      "trait_type": "<0>",      "value": "<1>"    }
--------------------------------------------------------------
4. Создать коллекцию
{  "collectionContent": "<0>",  "commonContent": "<1>",  "royaltyFactor": <2>,  "royaltyBase": <3>,  "royaltyAddress": "<4>",  "amount": "<5>"}

--------------------------------------------------------------
5. Изменить параметры коллекции
{  "addressCollection": "<0>",  "next_item_index": <1>,  "collection_content": "<2>",  "owner_address": "<3>",  "offchain": "offchain",  "common_content": "<4>",  "individual_nft_content": "h",  "royality_perc": <5>,  "royality_int2": <6>,  "royality_address": "<7>",  "pref": 1}

--------------------------------------------------------------
6. Заминтить одиночный Nft
{    "collectionAddress" : "<0>",    "value": "<1>",    "itemIndex": <2>,    "itemOwnerAddress": "<3>",    "itemContent": "<4>",    "amount": "<5>"}

--------------------------------------------------------------
7. Заминтить пакетный Nft
{    "collectionAddress" : "<0>",    "value": "<1>",    "itemIndex": <2>,    "amount": "<3>",    "itemsNft" : [<4>    ]  }

8. набор Item-ов для помещения внутрь пакетного минта Nft
      {        "itemOwnerAddress": "<0>"      }












